function Modelica.Blocks.Tables.Internal.getDerTable2DValue "Derivative of interpolated 2-dim. table defined by matrix"
  input Modelica.Blocks.Types.ExternalCombiTable2D tableID;
  input Real u1;
  input Real u2;
  input Real der_u1;
  input Real der_u2;
  output Real der_y;

  external "C" der_y = ModelicaStandardTables_CombiTable2D_getDerValue(tableID, u1, u2, der_u1, der_u2);
end Modelica.Blocks.Tables.Internal.getDerTable2DValue;

function Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmax "Return maximum abscissa value of 2-dim. table defined by matrix"
  input Modelica.Blocks.Types.ExternalCombiTable2D tableID;
  output Real[2] uMax "Maximum abscissa value in table";

  external "C" ModelicaStandardTables_CombiTable2D_maximumAbscissa(tableID, uMax);
end Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmax;

function Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmin "Return minimum abscissa value of 2-dim. table defined by matrix"
  input Modelica.Blocks.Types.ExternalCombiTable2D tableID;
  output Real[2] uMin "Minimum abscissa value in table";

  external "C" ModelicaStandardTables_CombiTable2D_minimumAbscissa(tableID, uMin);
end Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmin;

function Modelica.Blocks.Tables.Internal.getTable2DValue "Interpolate 2-dim. table defined by matrix"
  input Modelica.Blocks.Types.ExternalCombiTable2D tableID;
  input Real u1;
  input Real u2;
  output Real y;

  external "C" y = ModelicaStandardTables_CombiTable2D_getValue(tableID, u1, u2);
end Modelica.Blocks.Tables.Internal.getTable2DValue;

function Modelica.Blocks.Types.ExternalCombiTable2D.constructor "Initialize 2-dim. table defined by matrix"
  input String tableName "Table name";
  input String fileName "File name";
  input Real[:, :] table;
  input enumeration(LinearSegments, ContinuousDerivative, ConstantSegments, MonotoneContinuousDerivative1, MonotoneContinuousDerivative2) smoothness;
  input enumeration(HoldLastPoint, LastTwoPoints, Periodic, NoExtrapolation) extrapolation = Modelica.Blocks.Types.Extrapolation.LastTwoPoints;
  input Boolean verboseRead = true "= true: Print info message; = false: No info message";
  output Modelica.Blocks.Types.ExternalCombiTable2D externalCombiTable2D;

  external "C" externalCombiTable2D = ModelicaStandardTables_CombiTable2D_init2(fileName, tableName, table, size(table, 1), size(table, 2), smoothness, extrapolation, verboseRead);
end Modelica.Blocks.Types.ExternalCombiTable2D.constructor;

impure function Modelica.Blocks.Types.ExternalCombiTable2D.destructor "Terminate 2-dim. table defined by matrix"
  input Modelica.Blocks.Types.ExternalCombiTable2D externalCombiTable2D;

  external "C" ModelicaStandardTables_CombiTable2D_close(externalCombiTable2D);
end Modelica.Blocks.Types.ExternalCombiTable2D.destructor;

function Modelica.SIunits.Conversions.to_rpm "Inline before index reduction" "Convert from radian per second to revolutions per minute"
  input Real rs(quantity = "AngularVelocity", unit = "rad/s") "radian per second value";
  output Real rpm(quantity = "AngularVelocity", unit = "rev/min") "revolutions per minute value";
algorithm
  rpm := 9.549296585513721 * rs;
end Modelica.SIunits.Conversions.to_rpm;

function Modelica.Utilities.Strings.Advanced.skipWhiteSpace "Scan white space"
  input String string;
  input Integer startIndex(min = 1) = 1;
  output Integer nextIndex;

  external "C" nextIndex = ModelicaStrings_skipWhiteSpace(string, startIndex);
end Modelica.Utilities.Strings.Advanced.skipWhiteSpace;

function Modelica.Utilities.Strings.isEmpty "Return true if a string is empty (has only white space characters)"
  input String string;
  output Boolean result "True, if string is empty";
  protected Integer nextIndex;
  protected Integer len;
algorithm
  nextIndex := Modelica.Utilities.Strings.Advanced.skipWhiteSpace(string, 1);
  len := Modelica.Utilities.Strings.length(string);
  if len < 1 or nextIndex > len then
    result := true;
  else
    result := false;
  end if;
end Modelica.Utilities.Strings.isEmpty;

function Modelica.Utilities.Strings.length "Return length of string"
  input String string;
  output Integer result "Number of characters of string";

  external "C" result = ModelicaStrings_length(string);
end Modelica.Utilities.Strings.length;

class Symbench.FDM.Test
  parameter Real body_rotation.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
  Real body_rotation.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real body_rotation.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real eletric_ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real eletric_ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  parameter Real air_rotation.phi0(quantity = "Angle", unit = "rad", displayUnit = "deg") = 0.0 "Fixed offset angle of housing";
  Real air_rotation.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real air_rotation.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  parameter Real motor.Kt(quantity = "ElectricalTorqueConstant", unit = "N.m/A") = 0.008303736161316279 "torque constant";
  parameter Real motor.Rw(quantity = "Resistance", unit = "Ohm") = 0.075 "winding resistance";
  parameter Real motor.I_idle(quantity = "ElectricCurrent", unit = "A") = 0.85 "idle current";
  parameter Real motor.I_max(quantity = "ElectricCurrent", unit = "A") = 25.0 "maximum current";
  parameter Real motor.max_power(quantity = "Power", unit = "W") = 350.0 "maximum power";
  Real motor.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  parameter Real motor.widing_resistance.R(quantity = "Resistance", unit = "Ohm", start = 1.0) = motor.Rw "Resistance at temperature T_ref";
  parameter Real motor.widing_resistance.T_ref(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = 288.15, nominal = 300.0) = 300.15 "Reference temperature";
  parameter Real motor.widing_resistance.alpha(quantity = "LinearTemperatureCoefficient", unit = "1/K") = 0.0 "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
  Real motor.widing_resistance.v(quantity = "ElectricPotential", unit = "V") "Voltage drop of the two pins (= p.v - n.v)";
  Real motor.widing_resistance.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
  Real motor.widing_resistance.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.widing_resistance.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.widing_resistance.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.widing_resistance.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  final parameter Boolean motor.widing_resistance.useHeatPort = false "=true, if heatPort is enabled";
  parameter Real motor.widing_resistance.T(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = 288.15, nominal = 300.0) = motor.widing_resistance.T_ref "Fixed device temperature if useHeatPort = false";
  Real motor.widing_resistance.LossPower(quantity = "Power", unit = "W") "Loss power leaving component via heatPort";
  Real motor.widing_resistance.T_heatPort(quantity = "ThermodynamicTemperature", unit = "K", displayUnit = "degC", min = 0.0, start = 288.15, nominal = 300.0) "Temperature of heatPort";
  Real motor.widing_resistance.R_actual(quantity = "Resistance", unit = "Ohm") "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
  final parameter Boolean motor.emf.useSupport = true "= true, if support flange enabled, otherwise implicitly grounded";
  parameter Real motor.emf.k(quantity = "ElectricalTorqueConstant", unit = "N.m/A", start = 1.0) = motor.Kt "Transformation coefficient";
  Real motor.emf.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins";
  Real motor.emf.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from positive to negative pin";
  Real motor.emf.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Angle of shaft flange with respect to support (= flange.phi - support.phi)";
  Real motor.emf.w(quantity = "AngularVelocity", unit = "rad/s") "Angular velocity of flange relative to support";
  Real motor.emf.tau(quantity = "Torque", unit = "N.m") "Torque of flange";
  Real motor.emf.tauElectrical(quantity = "Torque", unit = "N.m") "Electrical torque";
  Real motor.emf.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.emf.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.emf.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.emf.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.emf.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real motor.emf.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real motor.emf.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real motor.emf.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  protected Real motor.emf.internalSupport.tau(quantity = "Torque", unit = "N.m") = -motor.emf.tau "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau)";
  protected Real motor.emf.internalSupport.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "External support angle (= flange.phi)";
  protected Real motor.emf.internalSupport.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  protected Real motor.emf.internalSupport.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  parameter Real motor.idle_current.I(quantity = "ElectricCurrent", unit = "A", start = 1.0) = motor.I_idle "Value of constant current";
  Real motor.idle_current.v(quantity = "ElectricPotential", unit = "V") "Voltage drop of the two pins (= p.v - n.v)";
  Real motor.idle_current.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
  Real motor.idle_current.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.idle_current.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.idle_current.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.idle_current.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.shaft.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real motor.shaft.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real motor.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real motor.support.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real motor.pin_p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.pin_p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.powerSensor.pc.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.powerSensor.pc.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.powerSensor.nc.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.powerSensor.nc.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.powerSensor.pv.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.powerSensor.pv.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.powerSensor.nv.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.powerSensor.nv.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.powerSensor.power(unit = "W") "Instantaneous power as output signal";
  Real motor.powerSensor.voltageSensor.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.powerSensor.voltageSensor.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.powerSensor.voltageSensor.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.powerSensor.voltageSensor.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.powerSensor.voltageSensor.v(unit = "V") "Voltage between pin p and n (= p.v - n.v) as output signal";
  Real motor.powerSensor.currentSensor.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.powerSensor.currentSensor.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.powerSensor.currentSensor.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real motor.powerSensor.currentSensor.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real motor.powerSensor.currentSensor.i(unit = "A") "Current in the branch from p to n as output signal";
  Real motor.powerSensor.product.u1 "Connector of Real input signal 1";
  Real motor.powerSensor.product.u2 "Connector of Real input signal 2";
  Real motor.powerSensor.product.y "Connector of Real output signal";
  parameter Real battery.V(quantity = "ElectricPotential", unit = "V") = 6.6 "nominal voltage";
  Real battery.pin_p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real battery.pin_p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real battery.pin_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real battery.pin_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  parameter Real battery.constantVoltage.V(quantity = "ElectricPotential", unit = "V", start = 1.0) = battery.V "Value of constant voltage";
  Real battery.constantVoltage.v(quantity = "ElectricPotential", unit = "V") "Voltage drop of the two pins (= p.v - n.v)";
  Real battery.constantVoltage.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
  Real battery.constantVoltage.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real battery.constantVoltage.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real battery.constantVoltage.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real battery.constantVoltage.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  parameter Real propeller.rho(quantity = "Density", unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) = 1.225 "air density";
  parameter String propeller.propellerName = "PER3_12x45MR" "propeller name";
  parameter Real propeller.radius(quantity = "Length", unit = "m", displayUnit = "mm") = 0.1524 "propeller radius";
  parameter Real propeller.Cp_scale(unit = "1") = 1.1 "Cp scaling";
  parameter Real propeller.Ct_scale(unit = "1") = 0.9 "Ct scaling";
  Real propeller.air_rotation.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real propeller.air_rotation.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real propeller.omega.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real propeller.omega.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real propeller.omega.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real propeller.omega.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real propeller.omega.phi_rel(quantity = "Angle", unit = "rad", displayUnit = "deg") "Relative angle between two flanges (flange_b.phi - flange_a.phi)";
  Real propeller.omega.w_rel(unit = "rad/s") "Relative angular velocity between two flanges (= der(flange_b.phi) - der(flange_a.phi)) as output signal";
  final parameter Boolean propeller.torque.useSupport = true "= true, if support flange enabled, otherwise implicitly grounded";
  Real propeller.torque.flange.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real propeller.torque.flange.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real propeller.torque.support.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") = propeller.torque.phi_support "Absolute rotation angle of flange";
  Real propeller.torque.support.tau(quantity = "Torque", unit = "N.m") = -propeller.torque.flange.tau "Cut torque in the flange";
  protected Real propeller.torque.phi_support(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute angle of support flange";
  Real propeller.torque.tau(unit = "N.m") "Accelerating torque acting at flange (= -flange.tau)";
  Real propeller.to_rpm.u(unit = "rad/s") "Connector of Real input signal to be converted";
  Real propeller.to_rpm.y(unit = "rev/min") "Connector of Real output signal containing input signal u in another unit";
  Real propeller.omega_square.u "Connector of Real input signal";
  Real propeller.omega_square.y "Connector of Real output signal";
  final parameter Real propeller.omega_square.exponent = 2.0 "Exponent of power";
  Real propeller.torque_product.u1 "Connector of Real input signal 1";
  Real propeller.torque_product.u2 "Connector of Real input signal 2";
  Real propeller.torque_product.y "Connector of Real output signal";
  parameter Real propeller.torque_gain.k(unit = "1", start = 1.0) = propeller.rho * propeller.Cp_scale / 248.0502134423985 * (2.0 * propeller.radius) ^ 5.0 "Gain value multiplied with input signal";
  Real propeller.torque_gain.u "Input signal connector";
  Real propeller.torque_gain.y "Output signal connector";
  constant String propeller.dataPath = "/home/mmaroti/workspace/modelica-symbench/Symbench/Data/";
  Real propeller.Cp_table.u1 "Connector of Real input signal 1";
  Real propeller.Cp_table.u2 "Connector of Real input signal 2";
  Real propeller.Cp_table.y "Connector of Real output signal";
  final parameter Boolean propeller.Cp_table.tableOnFile = true "= true, if table is defined on file or in function usertab";
  parameter String propeller.Cp_table.tableName = propeller.propellerName + "_Cp" "Table name on file or in function usertab (see docu)";
  parameter String propeller.Cp_table.fileName = "/home/mmaroti/workspace/modelica-symbench/Symbench/Data/propeller_tables.txt" "File where matrix is stored";
  parameter Boolean propeller.Cp_table.verboseRead = false "= true, if info message that file is loading is to be printed";
  final parameter enumeration(LinearSegments, ContinuousDerivative, ConstantSegments, MonotoneContinuousDerivative1, MonotoneContinuousDerivative2) propeller.Cp_table.smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
  final parameter enumeration(HoldLastPoint, LastTwoPoints, Periodic, NoExtrapolation) propeller.Cp_table.extrapolation = Modelica.Blocks.Types.Extrapolation.HoldLastPoint "Extrapolation of data outside the definition range";
  final parameter Boolean propeller.Cp_table.verboseExtrapolation = false "= true, if warning messages are to be printed if table input is outside the definition range";
  final parameter Real[2] propeller.Cp_table.u_min = Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmin(propeller.Cp_table.tableID) "Minimum abscissa value defined in table";
  final parameter Real[2] propeller.Cp_table.u_max = Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmax(propeller.Cp_table.tableID) "Maximum abscissa value defined in table";
  protected parameter Modelica.Blocks.Types.ExternalCombiTable2D propeller.Cp_table.tableID = Modelica.Blocks.Types.ExternalCombiTable2D.constructor(propeller.Cp_table.tableName, if propeller.Cp_table.fileName <> "NoName" and not Modelica.Utilities.Strings.isEmpty(propeller.Cp_table.fileName) then propeller.Cp_table.fileName else "NoName", {}, Modelica.Blocks.Types.Smoothness.LinearSegments, Modelica.Blocks.Types.Extrapolation.HoldLastPoint, propeller.Cp_table.verboseRead) "External table object";
  Real propeller.air_translation.s(quantity = "Length", unit = "m") "Absolute position of flange";
  Real propeller.air_translation.f(quantity = "Force", unit = "N") "Cut force directed into flange";
  Real propeller.body_translation.s(quantity = "Length", unit = "m") "Absolute position of flange";
  Real propeller.body_translation.f(quantity = "Force", unit = "N") "Cut force directed into flange";
  Real propeller.velocity.flange_a.s(quantity = "Length", unit = "m") "Absolute position of flange";
  Real propeller.velocity.flange_a.f(quantity = "Force", unit = "N") "Cut force directed into flange";
  Real propeller.velocity.flange_b.s(quantity = "Length", unit = "m") "Absolute position of flange";
  Real propeller.velocity.flange_b.f(quantity = "Force", unit = "N") "Cut force directed into flange";
  Real propeller.velocity.s_rel(quantity = "Length", unit = "m", start = 0.0, fixed = true) "Distance between the two flanges (flange_b.s - flange_a.s)";
  Real propeller.velocity.v_rel(unit = "m/s") "Relative velocity between two flanges (= der(flange_b.s) - der(flange_a.s)) as output signal";
  Real propeller.division.u1 "Connector of Real input signal 1";
  Real propeller.division.u2 "Connector of Real input signal 2";
  Real propeller.division.y "Connector of Real output signal";
  parameter Real propeller.j_gain.k(unit = "1", start = 1.0) = 6.283185307179586 / (2.0 * propeller.radius) "Gain value multiplied with input signal";
  Real propeller.j_gain.u "Input signal connector";
  Real propeller.j_gain.y "Output signal connector";
  Real propeller.Ct_table.u1 "Connector of Real input signal 1";
  Real propeller.Ct_table.u2 "Connector of Real input signal 2";
  Real propeller.Ct_table.y "Connector of Real output signal";
  final parameter Boolean propeller.Ct_table.tableOnFile = true "= true, if table is defined on file or in function usertab";
  parameter String propeller.Ct_table.tableName = propeller.propellerName + "_Ct" "Table name on file or in function usertab (see docu)";
  parameter String propeller.Ct_table.fileName = "/home/mmaroti/workspace/modelica-symbench/Symbench/Data/propeller_tables.txt" "File where matrix is stored";
  parameter Boolean propeller.Ct_table.verboseRead = false "= true, if info message that file is loading is to be printed";
  final parameter enumeration(LinearSegments, ContinuousDerivative, ConstantSegments, MonotoneContinuousDerivative1, MonotoneContinuousDerivative2) propeller.Ct_table.smoothness = Modelica.Blocks.Types.Smoothness.LinearSegments "Smoothness of table interpolation";
  final parameter enumeration(HoldLastPoint, LastTwoPoints, Periodic, NoExtrapolation) propeller.Ct_table.extrapolation = Modelica.Blocks.Types.Extrapolation.HoldLastPoint "Extrapolation of data outside the definition range";
  final parameter Boolean propeller.Ct_table.verboseExtrapolation = false "= true, if warning messages are to be printed if table input is outside the definition range";
  final parameter Real[2] propeller.Ct_table.u_min = Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmin(propeller.Ct_table.tableID) "Minimum abscissa value defined in table";
  final parameter Real[2] propeller.Ct_table.u_max = Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmax(propeller.Ct_table.tableID) "Maximum abscissa value defined in table";
  protected parameter Modelica.Blocks.Types.ExternalCombiTable2D propeller.Ct_table.tableID = Modelica.Blocks.Types.ExternalCombiTable2D.constructor(propeller.Ct_table.tableName, if propeller.Ct_table.fileName <> "NoName" and not Modelica.Utilities.Strings.isEmpty(propeller.Ct_table.fileName) then propeller.Ct_table.fileName else "NoName", {}, Modelica.Blocks.Types.Smoothness.LinearSegments, Modelica.Blocks.Types.Extrapolation.HoldLastPoint, propeller.Ct_table.verboseRead) "External table object";
  Real propeller.force_product.u1 "Connector of Real input signal 1";
  Real propeller.force_product.u2 "Connector of Real input signal 2";
  Real propeller.force_product.y "Connector of Real output signal";
  parameter Real propeller.force_gain.k(unit = "1", start = 1.0) = propeller.rho * propeller.Ct_scale / 39.47841760435743 * (2.0 * propeller.radius) ^ 4.0 "Gain value multiplied with input signal";
  Real propeller.force_gain.u "Input signal connector";
  Real propeller.force_gain.y "Output signal connector";
  Real propeller.shaft_rotation.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real propeller.shaft_rotation.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real propeller.force.flange_a.s(quantity = "Length", unit = "m") "Absolute position of flange";
  Real propeller.force.flange_a.f(quantity = "Force", unit = "N") "Cut force directed into flange";
  Real propeller.force.flange_b.s(quantity = "Length", unit = "m") "Absolute position of flange";
  Real propeller.force.flange_b.f(quantity = "Force", unit = "N") "Cut force directed into flange";
  Real propeller.force.f(unit = "N") "Driving force as input signal";
  Real propeller.max.u1 "Connector of Real input signal 1";
  Real propeller.max.u2 "Connector of Real input signal 2";
  Real propeller.max.y "Connector of Real output signal";
  parameter Real propeller.small.k(start = 1.0) = 1.0 "Constant output value";
  Real propeller.small.y "Connector of Real output signal";
  Real rotationalPower.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real rotationalPower.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real rotationalPower.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real rotationalPower.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real rotationalPower.power(unit = "W") "Power in flange flange_a as output signal";
  Real eletricalPower.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real eletricalPower.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real eletricalPower.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real eletricalPower.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real eletricalPower.power(unit = "W") "Instantaneous power as output signal";
  Real eletricalPower.voltageSensor.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real eletricalPower.voltageSensor.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real eletricalPower.voltageSensor.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real eletricalPower.voltageSensor.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real eletricalPower.voltageSensor.v(unit = "V") "Voltage between pin p and n (= p.v - n.v) as output signal";
  Real eletricalPower.currentSensor.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real eletricalPower.currentSensor.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real eletricalPower.currentSensor.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real eletricalPower.currentSensor.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real eletricalPower.currentSensor.i(unit = "A") "Current in the branch from p to n as output signal";
  Real eletricalPower.product.u1 "Connector of Real input signal 1";
  Real eletricalPower.product.u2 "Connector of Real input signal 2";
  Real eletricalPower.product.y "Connector of Real output signal";
  Real eletricalPower.ground.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real eletricalPower.ground.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  parameter Real esc.efficiency(unit = "1") = 0.95 "energy efficiency";
  parameter Real esc.Rw(quantity = "Resistance", unit = "Ohm") = 0.075 "motor winding resistance";
  parameter Real esc.I_idle(quantity = "ElectricCurrent", unit = "A") = 0.85 "motor idle current";
  Real esc.battery_p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.battery_p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.motor_p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.motor_p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.battery_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.battery_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.motor_n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.motor_n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.battery_voltage.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.battery_voltage.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.battery_voltage.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.battery_voltage.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.battery_voltage.v(unit = "V") "Voltage between pin p and n (= p.v - n.v) as output signal";
  Real esc.motor_voltage.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.motor_voltage.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.motor_voltage.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.motor_voltage.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.motor_voltage.v(unit = "V") "Voltage between pin p and n (= p.v - n.v) as input signal";
  Real esc.motor_voltage.i(quantity = "ElectricCurrent", unit = "A") "Current flowing from pin p to pin n";
  Real esc.battery_current.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.battery_current.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.battery_current.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.battery_current.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.battery_current.v(quantity = "ElectricPotential", unit = "V") "Voltage drop between the two pins (= p.v - n.v)";
  Real esc.battery_current.i(unit = "A") "Current flowing from pin p to pin n as input signal";
  Real esc.speed;
  Real esc.product1.u1 "Connector of Real input signal 1";
  Real esc.product1.u2 "Connector of Real input signal 2";
  Real esc.product1.y "Connector of Real output signal";
  parameter Real esc.gain.k(unit = "1", start = 1.0) = 1.0 / esc.efficiency "Gain value multiplied with input signal";
  Real esc.gain.u "Input signal connector";
  Real esc.gain.y "Output signal connector";
  Real esc.motor_power.pc.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.motor_power.pc.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.motor_power.nc.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.motor_power.nc.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.motor_power.pv.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.motor_power.pv.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.motor_power.nv.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.motor_power.nv.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.motor_power.power(unit = "W") "Instantaneous power as output signal";
  Real esc.motor_power.voltageSensor.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.motor_power.voltageSensor.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.motor_power.voltageSensor.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.motor_power.voltageSensor.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.motor_power.voltageSensor.v(unit = "V") "Voltage between pin p and n (= p.v - n.v) as output signal";
  Real esc.motor_power.currentSensor.p.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.motor_power.currentSensor.p.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.motor_power.currentSensor.n.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real esc.motor_power.currentSensor.n.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real esc.motor_power.currentSensor.i(unit = "A") "Current in the branch from p to n as output signal";
  Real esc.motor_power.product.u1 "Connector of Real input signal 1";
  Real esc.motor_power.product.u2 "Connector of Real input signal 2";
  Real esc.motor_power.product.y "Connector of Real output signal";
  Real esc.division.u1 "Connector of Real input signal 1";
  Real esc.division.u2 "Connector of Real input signal 2";
  Real esc.division.y "Connector of Real output signal";
  parameter Real esc.idle_voltage.k(start = 1.0) = esc.Rw * esc.I_idle "Constant output value";
  Real esc.idle_voltage.y "Connector of Real output signal";
  Real esc.add.u1 "Connector of Real input signal 1";
  Real esc.add.u2 "Connector of Real input signal 2";
  Real esc.add.y "Connector of Real output signal";
  parameter Real esc.add.k1 = 1.0 "Gain of input signal 1";
  parameter Real esc.add.k2 = 1.0 "Gain of input signal 2";
  Real esc.sub.u1 "Connector of Real input signal 1";
  Real esc.sub.u2 "Connector of Real input signal 2";
  Real esc.sub.y "Connector of Real output signal";
  parameter Real esc.sub.k1 = -1.0 "Gain of input signal 1";
  parameter Real esc.sub.k2 = 1.0 "Gain of input signal 2";
  parameter Real air_translation.s0(quantity = "Length", unit = "m") = 0.0 "Fixed offset position of housing";
  Real air_translation.flange.s(quantity = "Length", unit = "m") "Absolute position of flange";
  Real air_translation.flange.f(quantity = "Force", unit = "N") "Cut force directed into flange";
  Real inertia.flange_a.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real inertia.flange_a.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  Real inertia.flange_b.phi(quantity = "Angle", unit = "rad", displayUnit = "deg") "Absolute rotation angle of flange";
  Real inertia.flange_b.tau(quantity = "Torque", unit = "N.m") "Cut torque in the flange";
  parameter Real inertia.J(quantity = "MomentOfInertia", unit = "kg.m2", min = 0.0, start = 1.0) = 0.0001 "Moment of inertia";
  final parameter enumeration(never, avoid, default, prefer, always) inertia.stateSelect = StateSelect.default "Priority to use phi and w as states";
  Real inertia.phi(quantity = "Angle", unit = "rad", displayUnit = "rad", start = 0.0, fixed = true, stateSelect = StateSelect.default) "Absolute rotation angle of component";
  Real inertia.w(quantity = "AngularVelocity", unit = "rad/s", start = 570.0, fixed = false, stateSelect = StateSelect.default) "Absolute angular velocity of component (= der(phi))";
  Real inertia.a(quantity = "AngularAcceleration", unit = "rad/s2", start = 0.0, fixed = true) "Absolute angular acceleration of component (= der(w))";
  final parameter Boolean body_speed.useSupport = false "= true, if support flange enabled, otherwise implicitly grounded";
  Real body_speed.s(quantity = "Length", unit = "m") "Distance between flange and support (= flange.s - support.s)";
  Real body_speed.flange.s(quantity = "Length", unit = "m") "Absolute position of flange";
  Real body_speed.flange.f(quantity = "Force", unit = "N") "Cut force directed into flange";
  protected Real body_speed.s_support(quantity = "Length", unit = "m") "Absolute position of support flange";
  Real body_speed.f(quantity = "Force", unit = "N") "Accelerating force acting at flange (= flange.f)";
  parameter Real body_speed.v_fixed(quantity = "Velocity", unit = "m/s") = 0.0 "Fixed speed (if negative, force is acting as load)";
  Real body_speed.v(quantity = "Velocity", unit = "m/s") "Velocity of flange with respect to support (= der(s))";
  Real translationalPower.flange_a.s(quantity = "Length", unit = "m") "Absolute position of flange";
  Real translationalPower.flange_a.f(quantity = "Force", unit = "N") "Cut force directed into flange";
  Real translationalPower.flange_b.s(quantity = "Length", unit = "m") "Absolute position of flange";
  Real translationalPower.flange_b.f(quantity = "Force", unit = "N") "Cut force directed into flange";
  Real translationalPower.power(unit = "W") "Power in flange flange_a as output signal";
  parameter Real const.k(start = 1.0) = 0.9 "Constant output value";
  Real const.y "Connector of Real output signal";
equation
  motor.emf.internalSupport.flange.phi = motor.emf.support.phi;
  motor.powerSensor.pv.v = motor.powerSensor.voltageSensor.p.v;
  motor.powerSensor.voltageSensor.p.i - motor.powerSensor.pv.i = 0.0;
  motor.powerSensor.voltageSensor.n.v = motor.powerSensor.nv.v;
  motor.powerSensor.pc.v = motor.powerSensor.currentSensor.p.v;
  motor.powerSensor.currentSensor.p.i - motor.powerSensor.pc.i = 0.0;
  motor.powerSensor.currentSensor.n.v = motor.powerSensor.nc.v;
  motor.powerSensor.currentSensor.i = motor.powerSensor.product.u2;
  motor.powerSensor.voltageSensor.v = motor.powerSensor.product.u1;
  motor.powerSensor.product.y = motor.powerSensor.power;
  motor.widing_resistance.n.v = motor.idle_current.p.v;
  motor.widing_resistance.n.v = motor.emf.p.v;
  motor.powerSensor.nv.v = motor.pin_n.v;
  motor.powerSensor.nv.v = motor.idle_current.n.v;
  motor.powerSensor.nv.v = motor.emf.n.v;
  motor.emf.flange.phi = motor.shaft.phi;
  motor.support.phi = motor.emf.support.phi;
  motor.emf.support.tau - motor.support.tau = 0.0;
  motor.powerSensor.pv.v = motor.pin_p.v;
  motor.powerSensor.pv.v = motor.powerSensor.pc.v;
  motor.powerSensor.nc.v = motor.widing_resistance.p.v;
  battery.constantVoltage.p.v = battery.pin_p.v;
  battery.constantVoltage.n.v = battery.pin_n.v;
  propeller.torque.flange.phi = propeller.air_rotation.phi;
  propeller.torque.flange.phi = propeller.omega.flange_a.phi;
  propeller.to_rpm.y = propeller.Ct_table.u1;
  propeller.to_rpm.y = propeller.Cp_table.u1;
  propeller.force.flange_a.s = propeller.body_translation.s;
  propeller.force.flange_a.s = propeller.velocity.flange_b.s;
  propeller.division.y = propeller.j_gain.u;
  propeller.j_gain.y = propeller.Ct_table.u2;
  propeller.j_gain.y = propeller.Cp_table.u2;
  propeller.torque_product.u2 = propeller.Cp_table.y;
  propeller.torque_product.y = propeller.torque_gain.u;
  propeller.omega_square.y = propeller.force_product.u2;
  propeller.omega_square.y = propeller.torque_product.u1;
  propeller.Ct_table.y = propeller.force_product.u1;
  propeller.force_product.y = propeller.force_gain.u;
  propeller.torque_gain.y = propeller.torque.tau;
  propeller.torque.support.phi = propeller.shaft_rotation.phi;
  propeller.torque.support.phi = propeller.omega.flange_b.phi;
  propeller.omega.w_rel = propeller.max.u1;
  propeller.omega.w_rel = propeller.omega_square.u;
  propeller.omega.w_rel = propeller.to_rpm.u;
  propeller.air_translation.s = propeller.force.flange_b.s;
  propeller.air_translation.s = propeller.velocity.flange_a.s;
  propeller.division.u1 = propeller.velocity.v_rel;
  propeller.force_gain.y = propeller.force.f;
  propeller.division.u2 = propeller.max.y;
  propeller.small.y = propeller.max.u2;
  eletricalPower.p.v = eletricalPower.currentSensor.p.v;
  eletricalPower.currentSensor.p.i - eletricalPower.p.i = 0.0;
  eletricalPower.currentSensor.n.v = eletricalPower.voltageSensor.p.v;
  eletricalPower.currentSensor.n.v = eletricalPower.n.v;
  eletricalPower.currentSensor.n.i + eletricalPower.voltageSensor.p.i - eletricalPower.n.i = 0.0;
  eletricalPower.currentSensor.i = eletricalPower.product.u2;
  eletricalPower.voltageSensor.v = eletricalPower.product.u1;
  eletricalPower.product.y = eletricalPower.power;
  eletricalPower.voltageSensor.n.v = eletricalPower.ground.p.v;
  esc.motor_power.pv.v = esc.motor_power.voltageSensor.p.v;
  esc.motor_power.voltageSensor.p.i - esc.motor_power.pv.i = 0.0;
  esc.motor_power.voltageSensor.n.v = esc.motor_power.nv.v;
  esc.motor_power.pc.v = esc.motor_power.currentSensor.p.v;
  esc.motor_power.currentSensor.p.i - esc.motor_power.pc.i = 0.0;
  esc.motor_power.currentSensor.n.v = esc.motor_power.nc.v;
  esc.motor_power.currentSensor.i = esc.motor_power.product.u2;
  esc.motor_power.voltageSensor.v = esc.motor_power.product.u1;
  esc.motor_power.product.y = esc.motor_power.power;
  esc.gain.y = esc.battery_current.i;
  esc.motor_power.nv.v = esc.motor_n.v;
  esc.motor_power.nv.v = esc.motor_voltage.n.v;
  esc.battery_n.v = esc.battery_voltage.n.v;
  esc.battery_n.v = esc.battery_current.p.v;
  esc.battery_voltage.p.v = esc.battery_p.v;
  esc.battery_voltage.p.v = esc.battery_current.n.v;
  esc.motor_voltage.p.v = esc.motor_power.pc.v;
  esc.motor_power.pv.v = esc.motor_p.v;
  esc.motor_power.pv.v = esc.motor_power.nc.v;
  esc.division.y = esc.gain.u;
  esc.add.y = esc.motor_voltage.v;
  esc.product1.y = esc.add.u2;
  esc.speed = esc.product1.u1;
  esc.sub.y = esc.product1.u2;
  esc.battery_voltage.v = esc.division.u2;
  esc.battery_voltage.v = esc.sub.u2;
  esc.idle_voltage.y = esc.add.u1;
  esc.idle_voltage.y = esc.sub.u1;
  esc.motor_power.power = esc.division.u1;
  esc.battery_n.v = esc.motor_n.v;
  esc.battery_n.v = motor.pin_n.v;
  esc.battery_n.v = battery.pin_n.v;
  esc.battery_n.v = eletric_ground.p.v;
  body_rotation.flange.phi = motor.support.phi;
  propeller.air_rotation.phi = air_rotation.flange.phi;
  inertia.flange_b.phi = motor.shaft.phi;
  inertia.flange_b.phi = rotationalPower.flange_a.phi;
  rotationalPower.flange_b.phi = propeller.shaft_rotation.phi;
  motor.pin_p.v = esc.motor_p.v;
  battery.pin_p.v = eletricalPower.n.v;
  eletricalPower.p.v = esc.battery_p.v;
  propeller.air_translation.s = air_translation.flange.s;
  body_speed.flange.s = translationalPower.flange_a.s;
  translationalPower.flange_b.s = propeller.body_translation.s;
  const.y = esc.speed;
  motor.support.tau + body_rotation.flange.tau = 0.0;
  esc.motor_n.i + esc.battery_n.i + battery.pin_n.i + motor.pin_n.i + eletric_ground.p.i = 0.0;
  motor.idle_current.p.i + motor.emf.p.i + motor.widing_resistance.n.i = 0.0;
  motor.powerSensor.nv.i + motor.idle_current.n.i + motor.emf.n.i - motor.pin_n.i = 0.0;
  motor.emf.flange.tau - motor.shaft.tau = 0.0;
  motor.emf.internalSupport.flange.tau - motor.emf.support.tau = 0.0;
  esc.motor_p.i + motor.pin_p.i = 0.0;
  motor.powerSensor.pv.i + motor.powerSensor.pc.i - motor.pin_p.i = 0.0;
  motor.powerSensor.nc.i + motor.widing_resistance.p.i = 0.0;
  motor.powerSensor.voltageSensor.n.i - motor.powerSensor.nv.i = 0.0;
  motor.powerSensor.currentSensor.n.i - motor.powerSensor.nc.i = 0.0;
  eletricalPower.n.i + battery.pin_p.i = 0.0;
  battery.constantVoltage.p.i - battery.pin_p.i = 0.0;
  battery.constantVoltage.n.i - battery.pin_n.i = 0.0;
  propeller.air_rotation.tau + air_rotation.flange.tau = 0.0;
  propeller.torque.flange.tau + propeller.omega.flange_a.tau - propeller.air_rotation.tau = 0.0;
  propeller.torque.support.tau + propeller.omega.flange_b.tau - propeller.shaft_rotation.tau = 0.0;
  air_translation.flange.f + propeller.air_translation.f = 0.0;
  propeller.force.flange_b.f + propeller.velocity.flange_a.f - propeller.air_translation.f = 0.0;
  propeller.force.flange_a.f + propeller.velocity.flange_b.f - propeller.body_translation.f = 0.0;
  inertia.flange_b.tau + rotationalPower.flange_a.tau + motor.shaft.tau = 0.0;
  rotationalPower.flange_b.tau + propeller.shaft_rotation.tau = 0.0;
  esc.battery_p.i + eletricalPower.p.i = 0.0;
  eletricalPower.ground.p.i + eletricalPower.voltageSensor.n.i = 0.0;
  esc.motor_power.pc.i + esc.motor_voltage.p.i = 0.0;
  esc.motor_power.nv.i + esc.motor_voltage.n.i - esc.motor_n.i = 0.0;
  esc.battery_current.p.i + esc.battery_voltage.n.i - esc.battery_n.i = 0.0;
  esc.battery_current.n.i + esc.battery_voltage.p.i - esc.battery_p.i = 0.0;
  esc.motor_power.pv.i + esc.motor_power.nc.i - esc.motor_p.i = 0.0;
  esc.motor_power.voltageSensor.n.i - esc.motor_power.nv.i = 0.0;
  esc.motor_power.currentSensor.n.i - esc.motor_power.nc.i = 0.0;
  inertia.flange_a.tau = 0.0;
  translationalPower.flange_a.f + body_speed.flange.f = 0.0;
  translationalPower.flange_b.f + propeller.body_translation.f = 0.0;
  body_rotation.flange.phi = body_rotation.phi0;
  eletric_ground.p.v = 0.0;
  air_rotation.flange.phi = air_rotation.phi0;
  assert(1.0 + motor.widing_resistance.alpha * (motor.widing_resistance.T_heatPort - motor.widing_resistance.T_ref) >= 1e-15, "Temperature outside scope of model!");
  motor.widing_resistance.R_actual = motor.widing_resistance.R * (1.0 + motor.widing_resistance.alpha * (motor.widing_resistance.T_heatPort - motor.widing_resistance.T_ref));
  motor.widing_resistance.v = motor.widing_resistance.R_actual * motor.widing_resistance.i;
  motor.widing_resistance.LossPower = motor.widing_resistance.v * motor.widing_resistance.i;
  motor.widing_resistance.T_heatPort = motor.widing_resistance.T;
  motor.widing_resistance.v = motor.widing_resistance.p.v - motor.widing_resistance.n.v;
  0.0 = motor.widing_resistance.p.i + motor.widing_resistance.n.i;
  motor.widing_resistance.i = motor.widing_resistance.p.i;
  motor.emf.internalSupport.flange.tau = motor.emf.internalSupport.tau;
  motor.emf.internalSupport.flange.phi = motor.emf.internalSupport.phi;
  motor.emf.v = motor.emf.p.v - motor.emf.n.v;
  0.0 = motor.emf.p.i + motor.emf.n.i;
  motor.emf.i = motor.emf.p.i;
  motor.emf.phi = motor.emf.flange.phi - motor.emf.internalSupport.phi;
  motor.emf.w = der(motor.emf.phi);
  motor.emf.k * motor.emf.w = motor.emf.v;
  motor.emf.tau = -motor.emf.k * motor.emf.i;
  motor.emf.tauElectrical = -motor.emf.tau;
  motor.emf.tau = motor.emf.flange.tau;
  motor.idle_current.i = motor.idle_current.I;
  motor.idle_current.v = motor.idle_current.p.v - motor.idle_current.n.v;
  0.0 = motor.idle_current.p.i + motor.idle_current.n.i;
  motor.idle_current.i = motor.idle_current.p.i;
  motor.powerSensor.voltageSensor.p.i = 0.0;
  motor.powerSensor.voltageSensor.n.i = 0.0;
  motor.powerSensor.voltageSensor.v = motor.powerSensor.voltageSensor.p.v - motor.powerSensor.voltageSensor.n.v;
  motor.powerSensor.currentSensor.p.v = motor.powerSensor.currentSensor.n.v;
  motor.powerSensor.currentSensor.p.i = motor.powerSensor.currentSensor.i;
  motor.powerSensor.currentSensor.n.i = -motor.powerSensor.currentSensor.i;
  motor.powerSensor.product.y = motor.powerSensor.product.u1 * motor.powerSensor.product.u2;
  assert(motor.powerSensor.currentSensor.i >= motor.I_idle, "motor current below idle current");
  assert(motor.powerSensor.currentSensor.i <= motor.I_max, "maximum motor current violation");
  assert(0.0 <= motor.powerSensor.power, "motor power cannot be negative");
  assert(motor.powerSensor.power <= motor.max_power, "maximum motor power violation");
  battery.constantVoltage.v = battery.constantVoltage.V;
  battery.constantVoltage.v = battery.constantVoltage.p.v - battery.constantVoltage.n.v;
  0.0 = battery.constantVoltage.p.i + battery.constantVoltage.n.i;
  battery.constantVoltage.i = battery.constantVoltage.p.i;
  propeller.omega.phi_rel = propeller.omega.flange_b.phi - propeller.omega.flange_a.phi;
  propeller.omega.w_rel = der(propeller.omega.phi_rel);
  0.0 = propeller.omega.flange_a.tau;
  0.0 = propeller.omega.flange_a.tau + propeller.omega.flange_b.tau;
  propeller.torque.flange.tau = -propeller.torque.tau;
  propeller.to_rpm.y = Modelica.SIunits.Conversions.to_rpm(propeller.to_rpm.u);
  propeller.omega_square.y = propeller.omega_square.u ^ 2.0;
  propeller.torque_product.y = propeller.torque_product.u1 * propeller.torque_product.u2;
  propeller.torque_gain.y = propeller.torque_gain.k * propeller.torque_gain.u;
  propeller.Cp_table.y = Modelica.Blocks.Tables.Internal.getTable2DValue(propeller.Cp_table.tableID, propeller.Cp_table.u1, propeller.Cp_table.u2);
  assert(propeller.Cp_table.tableName <> "NoName", "tableOnFile = true and no table name given");
  propeller.velocity.s_rel = propeller.velocity.flange_b.s - propeller.velocity.flange_a.s;
  propeller.velocity.v_rel = der(propeller.velocity.s_rel);
  0.0 = propeller.velocity.flange_a.f;
  0.0 = propeller.velocity.flange_a.f + propeller.velocity.flange_b.f;
  propeller.division.y = propeller.division.u1 / propeller.division.u2;
  propeller.j_gain.y = propeller.j_gain.k * propeller.j_gain.u;
  propeller.Ct_table.y = Modelica.Blocks.Tables.Internal.getTable2DValue(propeller.Ct_table.tableID, propeller.Ct_table.u1, propeller.Ct_table.u2);
  assert(propeller.Ct_table.tableName <> "NoName", "tableOnFile = true and no table name given");
  propeller.force_product.y = propeller.force_product.u1 * propeller.force_product.u2;
  propeller.force_gain.y = propeller.force_gain.k * propeller.force_gain.u;
  propeller.force.flange_a.f = propeller.force.f;
  propeller.force.flange_b.f = -propeller.force.f;
  propeller.max.y = max(propeller.max.u1, propeller.max.u2);
  propeller.small.y = propeller.small.k;
  rotationalPower.flange_a.phi = rotationalPower.flange_b.phi;
  rotationalPower.power = rotationalPower.flange_a.tau * der(rotationalPower.flange_a.phi);
  0.0 = rotationalPower.flange_a.tau + rotationalPower.flange_b.tau;
  eletricalPower.voltageSensor.p.i = 0.0;
  eletricalPower.voltageSensor.n.i = 0.0;
  eletricalPower.voltageSensor.v = eletricalPower.voltageSensor.p.v - eletricalPower.voltageSensor.n.v;
  eletricalPower.currentSensor.p.v = eletricalPower.currentSensor.n.v;
  eletricalPower.currentSensor.p.i = eletricalPower.currentSensor.i;
  eletricalPower.currentSensor.n.i = -eletricalPower.currentSensor.i;
  eletricalPower.product.y = eletricalPower.product.u1 * eletricalPower.product.u2;
  eletricalPower.ground.p.v = 0.0;
  esc.battery_voltage.p.i = 0.0;
  esc.battery_voltage.n.i = 0.0;
  esc.battery_voltage.v = esc.battery_voltage.p.v - esc.battery_voltage.n.v;
  esc.motor_voltage.v = esc.motor_voltage.p.v - esc.motor_voltage.n.v;
  0.0 = esc.motor_voltage.p.i + esc.motor_voltage.n.i;
  esc.motor_voltage.i = esc.motor_voltage.p.i;
  esc.battery_current.v = esc.battery_current.p.v - esc.battery_current.n.v;
  0.0 = esc.battery_current.p.i + esc.battery_current.n.i;
  esc.battery_current.i = esc.battery_current.p.i;
  esc.product1.y = esc.product1.u1 * esc.product1.u2;
  esc.gain.y = esc.gain.k * esc.gain.u;
  esc.motor_power.voltageSensor.p.i = 0.0;
  esc.motor_power.voltageSensor.n.i = 0.0;
  esc.motor_power.voltageSensor.v = esc.motor_power.voltageSensor.p.v - esc.motor_power.voltageSensor.n.v;
  esc.motor_power.currentSensor.p.v = esc.motor_power.currentSensor.n.v;
  esc.motor_power.currentSensor.p.i = esc.motor_power.currentSensor.i;
  esc.motor_power.currentSensor.n.i = -esc.motor_power.currentSensor.i;
  esc.motor_power.product.y = esc.motor_power.product.u1 * esc.motor_power.product.u2;
  esc.division.y = esc.division.u1 / esc.division.u2;
  esc.idle_voltage.y = esc.idle_voltage.k;
  esc.add.y = esc.add.k1 * esc.add.u1 + esc.add.k2 * esc.add.u2;
  esc.sub.y = esc.sub.k1 * esc.sub.u1 + esc.sub.k2 * esc.sub.u2;
  assert(0.0 <= esc.speed, "speed cannot be smaller than 0");
  assert(esc.speed <= 1.0, "speed cannot be larger than 1");
  air_translation.flange.s = air_translation.s0;
  inertia.phi = inertia.flange_a.phi;
  inertia.phi = inertia.flange_b.phi;
  inertia.w = der(inertia.phi);
  inertia.a = der(inertia.w);
  inertia.J * inertia.a = inertia.flange_a.tau + inertia.flange_b.tau;
  body_speed.v = der(body_speed.s);
  body_speed.v = body_speed.v_fixed;
  body_speed.f = body_speed.flange.f;
  body_speed.s = body_speed.flange.s - body_speed.s_support;
  body_speed.s_support = 0.0;
  translationalPower.flange_a.s = translationalPower.flange_b.s;
  translationalPower.power = translationalPower.flange_a.f * der(translationalPower.flange_a.s);
  0.0 = translationalPower.flange_a.f + translationalPower.flange_b.f;
  const.y = const.k;
end Symbench.FDM.Test;
